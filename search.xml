<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>C++ 宏定义妙用</title>
      <link href="/2018/12/19/hong/"/>
      <url>/2018/12/19/hong/</url>
      
        <content type="html"><![CDATA[<p>今天看某工程的 c++ 代码，其中看到一个很 tricky 且实用的宏定义语法糖，可以让代码可读性变强。</p><p>下面解析一下：</p><pre><code class="c">#define HEAT(i, j, k) heatmap[k + h3 * (j + h2 * i)]... ...foo = HEAT(y, x, k);</code></pre><p>也就是说，代码块里面看起来 <code>HEAT</code> 是一个很漂亮的 3d 张量，但其实本质是一个自定义的一维数组。<br>初次见到这种宏定义用法的时候惊呼妙极了 （どうしょうもねえ =_=）。</p><p>当然了，这只能实现索引的包装，python 中那种切片索引还是没法实现的。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm Exercise </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Failed to initialize NVML driver/library version mismatch</title>
      <link href="/2018/11/19/nvidia-smi-problem/"/>
      <url>/2018/11/19/nvidia-smi-problem/</url>
      
        <content type="html"><![CDATA[<h1 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h1><p>Ubuntu 16.04 下，手贱更新了一下 apt-get 更新 vim 编辑器后，所有 DL 框架都莫名其妙找不到 GPU 了，<code>nvidia-smi</code> 提示 <code>Failed to initialize NVML driver/library version mismatch</code>。</p><p>于是，在两天两夜的延长作战过程中，我尝试了几乎所有能搜索到的方法，以下这些统统无效：</p><ol><li>无数次重启</li><li>purge 掉 nvida 所有驱动和 cuda-toolkit 然后重装 cuda</li><li>重启后，rmmod <code>nvidia-uvm</code>, <code>nvidia-modeset</code> 等依赖（<code>lsmod | grep -i nvidia</code> 可以查具体有哪些依赖），然后再运行 <code>nvidia-smi</code></li><li><code>cat /proc/drivers/nvidia/version</code> 找到对应的驱动版本，然后从英伟达官网下载对应驱动，手动安装（不过提示 gcc 版本不对，没装成功）</li></ol><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p><code>sudo apt-get autoclean</code></p><p>。。。</p><p>还我周末两天…（暴毙</p><h1 id="除后患"><a href="#除后患" class="headerlink" title="除后患"></a>除后患</h1><p>禁止 apt 应用偷偷更新驱动： <code>sudo vim /etc/apt/apt.conf.d/50unattended-upgrades</code>,</p><p>把下面大括号内的配置全部注释掉：</p><img src="/nvidia-smi/unintended.png" class="[class names]" title="[26] [16] [50unattended-upgrades [alt text]]">]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Keras 中使用 generator 解决训练中内存泄漏的问题</title>
      <link href="/2018/08/01/keras_training_generator/"/>
      <url>/2018/08/01/keras_training_generator/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>Keras 初心者（我）不熟悉 GPU 训练中的内存控制方法，近日在训练 VGG16 模型的时候总是出现 ResourceExhaustedError 的错误。一开始百思不得其解，因为服务器上的 GPU 的显存大概有 12 GB，正常应该是够用的。</p><p>如果看报错信息，很可能会误以为是卷积层参数问题：</p><pre><code class="bash">tensorflow.python.framework.errors_impl.ResourceExhaustedError: OOM when allocating tensor with shape[1024,32,224,224] and type float on /job:localhost/replica:0/task:0/device:GPU:0 by allocator GPU_0_bfc     [[Node: conv1_1/convolution = Conv2D[T=DT_FLOAT, _class=[&quot;loc:@gradients/conv1_1/convolution_grad/Conv2DBackpropFilter&quot;], data_format=&quot;NCHW&quot;, dilations=[1, 1, 1, 1], padding=&quot;SAME&quot;, strides=[1, 1, 1, 1], use_cudnn_on_gpu=true, _device=&quot;/job:localhost/replica:0/task:0/device:GPU:0&quot;](gradients/conv1_1/convolution_grad/Conv2DBackpropFilter-0-TransposeNHWCToNCHW-LayoutOptimizer, conv1_1/kernel/read)]]Current usage from device: /job:localhost/replica:0/task:0/device:GPU:0, allocator: GPU_0_bfc  588.00MiB from gradients/conv1_1/convolution_grad/Conv2DBackpropFilter-0-TransposeNHWCToNCHW-LayoutOptimizer  12.25MiB from mul_168  12.25MiB from add_109  12.25MiB from mul_164  576.0KiB from mul_108  576.0KiB from add_69  576.0KiB from mul_104  576.0KiB from mul_120  576.0KiB from add_77  576.0KiB from mul_116  576.0KiB from mul_132  576.0KiB from add_85  576.0KiB from mul_128  Remaining 85 nodes with 6.21MiB  ······  ······</code></pre><p>But 实际上，由于模型的训练需要用到大批量的训练数据。如果使用 <code>model.fit</code> 进行训练，内存中的训练数据会全部送入 GPU 显存中，占满显存空间。<br>解决方法就是使用 <a href="https://keras.io/models/model/" target="_blank" rel="noopener"><code>model.fit_generator</code></a> ，将训练数据分批送入 GPU 中的训练进程。</p><p><strong>注意</strong>：对于 12GB 显存，每批数据的大小即 <code>batch_size</code> 最好设置为 128 ~ 256，否则太大了还是会报错。</p><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><h2 id="训练代码："><a href="#训练代码：" class="headerlink" title="训练代码："></a>训练代码：</h2><pre><code class="python"># data_loader 是自己写的一个的类，里面包含 model.fit_generator 函数需要的 generatordl = data_loader()history = model.fit_generator(dl.data_loader(input_shape=input_shape),    # 输入训练集生成器  steps_per_epoch=messageConfig[&#39;train_batch_steps&#39;],  validation_steps=1, verbose=1, epochs=50, callbacks=[checkpoint],  validation_data=dl.data_loader(input_shape=input_shape, option=&#39;val&#39;))# 输入验证集生成器</code></pre><h2 id="Generator："><a href="#Generator：" class="headerlink" title="Generator："></a>Generator：</h2><p>注意，生成器的输出格式必须为 <code>(input, output)</code> 或者 <code>({&#39;input_1&#39;: input_array_1, &#39;input_2&#39;: input_arrary_2}, {&#39;output&#39;: output_array})</code></p><pre><code class="python">class data_loader:    ......    def data_loader(self, input_shape=None, option=&#39;train&#39;, data_format=&#39;cannels_last&#39;, *args):        if input_shape:            self.input_shape = input_shape        H, W, C = self.input_shape[0], self.input_shape[1], self.input_shape[2]        erste, zweite, dritte = H, W, C        if data_format == &#39;channels_first&#39;:            erste, zweite, dritte = C, H, W        if option == &#39;train&#39;:            if args:                self.batch_size, self.val_size = args[0], args[1]            return self.generate_train_batch_index(erste, zweite, dritte)        elif option == &#39;test&#39;:            return self.generate_val_batch_index(erste, zweite, dritte)    def generate_train_batch_index(self, erste, zweite, dritte):        while True:            for i in range(self.train_batch_num):                # 返回一个 batch_size 大小的 (train_batch_image, train_batch_labels)                data = self.get_next_train_batch(i, erste, zweite, dritte)                    yield data</code></pre><p>经过这样一番折腾，终于可以继续和模型愉快地玩耍了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://stackoverflow.com/questions/39076388/tensorflow-deep-mnist-resource-exhausted-oom-when-allocating-tensor-with-shape" target="_blank" rel="noopener">Tensorflow Deep MNIST: Resource exhausted: OOM when allocating tensor with shape[10000,32,28,28]</a></p><p><a href="https://github.com/keras-team/keras/issues/1627" target="_blank" rel="noopener">A concrete example for using data generator for large datasets such as ImageNet #1627</a></p>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>week1</title>
      <link href="/2018/08/01/SM5w1/"/>
      <url>/2018/08/01/SM5w1/</url>
      
        <content type="html"><![CDATA[<h1 id="Notations"><a href="#Notations" class="headerlink" title="Notations"></a>Notations</h1><p>训练集中，第 i 个输入序列中的第 t 个<strong>特征值/向量</strong>(feature)：$x^{(i) &lt; t &gt; }$,<br>该输入序列的<strong>长度</strong>(即 feature 的个数)： $T_x^{(i)}$,<br>对应的第 i 个输出序列中的第 t 个值： $y^{(i) &lt; t &gt; }$ ，对应的输出序列长度： $T_y^{(i)}$</p><p>$$x:\quad x^{ &lt; 1 &gt; } \quad x^{ &lt; 2 &gt; } \quad x^{ &lt; 3 &gt; } \cdots x^{ &lt; t &gt; } \cdots x^{ &lt; T_x &gt; }$$</p><h1 id="简单模型"><a href="#简单模型" class="headerlink" title="简单模型"></a>简单模型</h1><p>$$\begin{align}a^{ &lt; 0 &gt; } &amp;= \mathbf{0} \\<br>a^{ &lt; t &gt; } &amp;= g(W_{aa}a^{ &lt; t-1 &gt; }+W_{ax}x^{ &lt; t &gt; }+b_a) = g(W_a [a^{ &lt; t -1 &gt; },x^{ &lt; t &gt; }]+b_a),\quad (g = tanh\quad or ReLU) \\<br>\hat{y}^{ &lt; t &gt; } &amp;= g(W_{ya}a^{&lt; t &gt; }+b_y),\quad (g = sigmoid \quad or\quad …)<br>\end{align}<br>$$<br>$$<br>\begin{align}\tilde{c} ^{ &lt; t &gt; } &amp;= \mathrm{tanh}(W_c [ c^{ &lt; t-1 &gt; }, x^{ &lt; t &gt; } ] + b_c) \\<br>\Gamma _u &amp;= \sigma (W_u [c^{ &lt; t-1 &gt; }, x^{ &lt; t &gt; } ]+b_u) \\<br>c^{ &lt; t &gt; } &amp;= \Gamma _u \ast \tilde{c} ^{ &lt; t &gt; } + (1- \Gamma _u) \ast c^{ &lt; t - 1 &gt; }<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>各种傅里叶</title>
      <link href="/2018/07/10/fourier/"/>
      <url>/2018/07/10/fourier/</url>
      
        <content type="html"><![CDATA[<h1 id="连续时间信号"><a href="#连续时间信号" class="headerlink" title="连续时间信号"></a>连续时间信号</h1><h2 id="傅里叶级数-CFS："><a href="#傅里叶级数-CFS：" class="headerlink" title="傅里叶级数 CFS："></a>傅里叶级数 CFS：</h2><p>正变换：$F_n = \frac{1}{T} \int_0 ^T f(t) e^{-jn \omega_0 t} \mathrm{d} t$<br>基频：$F_0  = a_0 = \frac{1}{T}\int_0^T f(t) \mathrm{d} t$<br>逆变换：$f(t) = \sum_{n=-\infty}^{\infty}F_n e^{jn\omega_0 t}$</p><h2 id="傅里叶变换-CFT："><a href="#傅里叶变换-CFT：" class="headerlink" title="傅里叶变换 CFT："></a>傅里叶变换 CFT：</h2><p>$\text{正变换：}F(\omega) = \int_{-\infty}^\infty f(t) e^{-j\omega t} \mathrm{d}t$<br>$\text{逆变换：}f(t) = \frac{1}{2\pi}\int_{-\infty}^\infty F(\omega) e^{j\omega t}\mathrm{d} \omega$</p><h3 id="常用变换公式："><a href="#常用变换公式：" class="headerlink" title="常用变换公式："></a>常用变换公式：</h3><p>$$\begin{equation}\begin{aligned}<br>\mathrm{rect}(\frac{t}{T}) = u(t + \frac{T}{2}) - u(t - \frac{T}{2}) &amp;\leftrightarrow T \mathrm{sinc}(\frac{T\omega}{2}) \\<br>e^{-\alpha t} &amp;\leftrightarrow \frac{1}{\alpha + j\omega} \\<br>\delta(t) &amp;\leftrightarrow 1 \\<br>\delta^\prime (t) &amp;\leftrightarrow j\omega \\<br>1 &amp;\leftrightarrow 2\pi \delta(\omega) \\<br>\sum_{k=-\infty}^{\infty}\delta(t-kT) &amp;\leftrightarrow \frac{2\pi}{T}\sum_{k=-\infty}^{\infty}\delta(\omega-k\frac{2\pi}{T}) \\<br>\mathrm{sgn}(t) = u(t) - u(- t) &amp;\leftrightarrow \frac{2}{j\omega} \\<br>u(t) &amp;\leftrightarrow \pi \delta(\omega) + \frac{1}{j\omega} \\<br>\cos(\omega_0 t) &amp;\leftrightarrow \pi[\delta(\omega - \omega_0) + \delta(\omega + \omega_0)] \\<br>\sin(\omega_0 t) &amp;\leftrightarrow \frac{\pi}{j}[\delta(\omega - \omega_0) - \delta(\omega + \omega_0)]<br>\end{aligned}\end{equation}$$</p><h3 id="CFT-性质："><a href="#CFT-性质：" class="headerlink" title="CFT 性质："></a>CFT 性质：</h3><p>$$\begin{equation}\begin{aligned}<br>F(t) &amp;\leftrightarrow 2\pi f(-\omega) \\<br>f(at) &amp;\leftrightarrow \frac{1}{|a|}F(\frac{\omega}{a}) \\<br>f_1(t) \ast f_2(t) &amp;\leftrightarrow F_1(\omega) \cdot F_2(\omega)<br>\\ f_1(t) \cdot f_2(t) &amp;\leftrightarrow \frac{1}{2\pi}[F_1(\omega) \ast F_2(\omega)]<br>\end{aligned}\end{equation}$$</p><p>ps: 这一块容易出现卷积积分的求解，</p><h4 id="一些简化计算的方法："><a href="#一些简化计算的方法：" class="headerlink" title="一些简化计算的方法："></a>一些简化计算的方法：</h4><h5 id="利用时移性质："><a href="#利用时移性质：" class="headerlink" title="利用时移性质："></a>利用时移性质：</h5><p>若 $x_1(t) \ast x_2(t) = v(t)$，<br>则：$x_1(t - t_1) \ast x_2(t - t_2) = v(t - t_1 - t_2)$</p><hr><p><strong>例</strong>：若 $x(t) = u(t + 4) - u(t + 2) + u(t - 2) - u(t - 4)$，求 $y(t) = x(t)\ast x(t)$，$x(t)$ 图像：<br><img src="/fourier/x.png" class="[class names]" title="[10] [8] [x [alt text]]"><br><strong>解</strong>：$x(t)$ 是 $u(t)$ 的线性组合，所以是 LTI 信号。可以用时移性质简化计算：<br>$$\begin{align}<br>y(t) &amp;=  x(t)\ast x(t) \\<br>&amp;= [u(t + 4) - u(t + 2) + u(t - 2) - u(t - 4)] \ast [u(t + 4) - u(t + 2) + u(t  - 2) - u(t - 4)] \\<br>&amp;= u(t + 4) \ast u(t + 4) - u(t + 2) \ast u(t + 4) + u(t - 2) \ast u(t + 4) + \cdots \quad\quad \text{(卷积的结合律)} \\<br>&amp;= (t + 8)u(t + 8) - (t + 6)u(t + 6) + (t + 2)u(t + 2) + \cdots\quad(\text{应用 }u(t)\ast u(t) = tu(t)) \\<br>\end{align}<br>$$<br>最后得到结果：<br>$y(t) = (t + 8)u(t + 8) - 2(t + 6)u(t + 6) + (t+ 4)u(t + 4) + 2(t + 2)u(t + 2) - 4tu(t) + 2(t - 2)u(t - 2) + (t - 4)u(t - 4) - 2(t - 6)u(t - 6) + (t - 8)u(t - 8)$<br><img src="/fourier/y.png" class="[class names]" title="[6] [3] [y [alt text]]"></p><hr><p>此外还有常用的：$\mathrm{rect}(t)\ast \mathrm{rect}(t)=(t+1)u(t+1)-2tu(t)+(t-1)u(t-1)$</p><h5 id="利用微、积分性质求解："><a href="#利用微、积分性质求解：" class="headerlink" title="利用微、积分性质求解："></a>利用微、积分性质求解：</h5><p>$$\begin{align}<br>f_1(t) \ast f_2(t) &amp;= \frac{\mathrm{d}}{\mathrm{d}t} \int_{-\infty}^t [f_1(\tau) \ast f_2(\tau)]\mathrm{d}\tau \\<br>&amp;= f_1 ^\prime (t) \ast \int_{-\infty}^t f_2(\tau)\mathrm{d} \tau<br>\end{align}$$<br>解题时选两个信号中一阶导数简单的那个求导，就可以间接解题。</p><h1 id="离散时间信号"><a href="#离散时间信号" class="headerlink" title="离散时间信号"></a>离散时间信号</h1><p>##傅里叶级数 DFS：</p><p>正变换：$c_k = \frac{1}{N}\sum_{n=<n>}x[n]e^{-jk\frac{2\pi}{N}n}$ ，<br>逆变换：$x[n] = \sum_{k=<n>}c_k e^{jk\frac{2\pi}{N}n}$</n></n></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>回溯法——迷宫问题 &amp; 图的遍历</title>
      <link href="/2018/03/15/recallAlgorithm/"/>
      <url>/2018/03/15/recallAlgorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>回溯法又叫试探法，literally， 搜索过程中碰到死路径的时候回溯到先前的某个状态尝试下一条路径，</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol><li>定义一个解空间，每一个解即为每一步采用的方法</li><li>利用适于搜索的方法组织解空间</li><li>深度优先法 (depth first) 搜索解空间</li></ol><p>第三步可以用盲目 (blind) 搜索的方法。相对应的也有启发式 (heuristic) 的搜索方法，即考虑问题的特有性质，选用合适的规则从而提高搜索的效率。引用回溯法解决路径比较多，即解空间庞大的问题的时候会很笨拙，但确是系统性求解的方法。</p><h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><h2 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h2><p>典型的迷宫是一个不完全无向图，从一个节点（迷宫入口）开始搜索是否能到达另一个实现定好的节点（迷宫出口），并记录下途经格节点及其边（路径）<br>解空间即是各个路口的集合</p><pre><code class="c">#include &lt;vector&gt;#include &lt;iosteam&gt;using namespace std;//express maze with a set of sequence of crossingclass Crossing{public:    int turn1;    int turn2;    int turn3;public:    Crossing(int turn1, int turn2, int turn3) //constructor    {        Crossing::turn1 = turn1;        Crossing::turn2 = turn2;        Crossing::turn3 = turn3;    };}class Maze{private:    int exit;    std::vector&lt;Crossing&gt; crossings; //set of crossings    std::vector&lt;int&gt; result; //stack saving forkspublic:    Maze(int the_exit, std::vector&lt;Crossing&gt; the_crossings)    {        exit = the_exit;        crossings = the_crossings;    };    findExit(int entrance);    getResult();};Maze::findExit(int entrance){    if (entrance)    {        if (entrance == Maze::exit || findExit(crossings[entrance].turn1) || findExit(crossings[entrance].turn2 || findExit(crossings[entrance].turn3)        {            result.push_back(entrance); //FIFO            return 1;        }    }    return 0;}Maze::getResult(){    findExit(1);    std::vector&lt;int&gt;::iterator tra = result.rend();    do    {        -- tra;        cout &lt;&lt; *tra &lt;&lt; &quot;-&gt;&quot;;    }while (tra != result.begin());    cout &lt;&lt; &quot;Exit&quot; &lt;&lt; endl;}int main(){    Crossing c1(2, 0, 0);    Crossing c2(4, 0, 0);    Crossing c3(0, 0, 0); //dead    Crossing c4(3, 5, 0);    Crossing c5(6, 0, 0);    Crossing c6(7, 0, 0);    Crossing c7(8, 9, 0);    Crossing c8(0, 0, 0);    Crossing c9(10, 0, 0);    Crossing c0(0, 0, 0);    std::vector&lt;Crossing&gt; crossings;    crossings.push_back(c0);    crossings.push_back(c1);    crossings.push_back(c2);    crossings.push_back(c3);    crossings.push_back(c4);    crossings.push_back(c5);    crossings.push_back(c6);    crossings.push_back(c7);    crossings.push_back(c8);    crossings.push_back(c9);    Maze newMaze(10, crossings);    newMaze.getResult();    return 0;}</code></pre><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>左飞，《算法之美》</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm Exercise </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Check Opening Brackets</title>
      <link href="/2018/02/18/opening-brackets/"/>
      <url>/2018/02/18/opening-brackets/</url>
      
        <content type="html"><![CDATA[<p>用堆栈实现字符串中不匹配括号的检查，堆栈结构用 List 实现。<br>失配时输出 1 ，通过检查输出 Success。</p><p><strong>Python 版本：</strong></p><pre><code class="python">import sysclass Bracket:    def __init__(self, bracket_type, position):        self.bracket_type = bracket_type        self.position = position    def Match(self, c):        if self.bracket_type == &#39;[&#39; and c == &#39;]&#39;:            return True        if self.bracket_type == &#39;{&#39; and c == &#39;}&#39;:            return True        if self.bracket_type == &#39;(&#39; and c == &#39;)&#39;:            return True        return Falseif __name__ == &quot;__main__&quot;:    text = sys.stdin.read()    opening_brackets_stack = []                             #用List类型实现栈    for i, next in enumerate(text):        if next == &#39;(&#39; or next == &#39;[&#39; or next == &#39;{&#39;:            opening_brackets_stack.append((next, i))        #相当于push操作        if next == &#39;)&#39; or next == &#39;]&#39; or next == &#39;}&#39;:            if not opening_brackets_stack:                  #第一个字符是三种右括号时                opening_brackets_stack.append(False)        #随便放点东西到栈里面                break                                       #方便输出时的判断            else:                (b, position) = opening_brackets_stack.pop()                brckt = Bracket(b, position)                if not brckt.Match(next):                                       opening_brackets_stack.append(False)                    break    if not opening_brackets_stack:                          #空栈意味着所有的左括号都已经出栈，        print(&quot;Success\n&quot;)                                  #并且和右括号匹配了    else:        print(&quot;1\n&quot;)</code></pre><p><strong>C++ 版本：</strong></p><p>注意 c++ 里面 <code>std::stack::top()</code> 方法要加上<code>pop()</code> 才等同于 Python 中的 pop()，比较恶心。</p><pre><code class="c">#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;struct Bracket {    Bracket(char type, int position):       //初始化列表        type(type),                 //the 1st &quot;type&quot; is private attr, the 2nd is passed-in variable.        position(position)    {}    bool Matchc(char c) {        if (type == &#39;[&#39; &amp;&amp; c == &#39;]&#39;)            return true;        if (type == &#39;{&#39; &amp;&amp; c == &#39;}&#39;)            return true;        if (type == &#39;(&#39; &amp;&amp; c == &#39;)&#39;)            return true;        return false;    }    char type;    int position;};int main() {    std::string text;    getline(std::cin, text);    std::stack &lt;Bracket&gt; opening_brackets_stack;    for (int position = 0; position &lt; text.length(); ++position) {        char next = text[position];         if (next == &#39;(&#39; || next == &#39;[&#39; || next == &#39;{&#39;) {            opening_brackets_stack.push(Bracket(next, position));        }        if (next == &#39;)&#39; || next == &#39;]&#39; || next == &#39;}&#39;) {            if (opening_brackets_stack.empty())            {                opening_brackets_stack.push(Bracket(next, position));                break;            }else            {                struct Bracket brckt = opening_brackets_stack.top();                opening_brackets_stack.pop();                if (!brckt.Matchc(next))                {                    //std::cout &lt;&lt; brckt.type &lt;&lt; std::endl;                    opening_brackets_stack.push(Bracket(next, position));                    break;                }            }        }    }    if (opening_brackets_stack.empty())    {        std::cout &lt;&lt; &quot;Success&quot; &lt;&lt; std::endl;    }else    {        std::cout &lt;&lt; &quot;1&quot; &lt;&lt; std::endl;    }    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm Exercise </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python 中 FIR 数字滤波器设计与时序信号处理——信号与系统大作业</title>
      <link href="/2017/12/26/signalsystem-project/"/>
      <url>/2017/12/26/signalsystem-project/</url>
      
        <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>FIR 即有限脉冲响应(finite impulse response)，它对应着无限脉冲响应。一般在现实生活中，由于数字方法处理信号时，不可能对无限长的信号进行测量和运算，而是取其有限的时间片段进行分析。能够做到的是用窗函数截断出近似的信号进行处理，或者对信号时间片段进行周期延拓等等方法。</p><p>FIR滤波器的特点：<br><blockquote><p><a href="http://blog.csdn.net/shenziheng1/article/details/53366067" target="_blank" rel="noopener">FIR</a> 滤波器可以得到严格的<strong>线性相位</strong>,但它的传递函数的极点固定在原点,只能通过改变零点位置来改变性能</p></blockquote></p><p>FIR 滤波器的设计方法主要有三种：窗函数法、频率抽样法和切比雪夫逼近方法。窗函数法较为简单易行，本次作业就窗函数设计的角度展开。</p><p>窗函数的“窗”指的是频谱上窗型的频率响应，在频域上有限宽度的窗，经过离散傅里叶反变换后，在时域上就是无限长的序列。不同形状的窗函数的滤波性能也不同，不仅取决于级数，还与因果与非因果等因素有关。</p><p>作业中的代码和演示在 Jupyter Notebook 中完成。</p><hr><p>In this project, with some previous Python programming experiences, I basically learned:</p><ol><li>How to complete basic tasks of data processing with fundamental python packages. (numpy, scipy, etc.)</li><li>How to design digital FIR filters with different module of FIRs.</li><li>The difference between 2 methods of signal filtering encapsuled within scipy.signal package.</li><li>How to read, extract and process data from wfdb-python package, which is an open source ECG dataset.</li></ol><h1 id="本编"><a href="#本编" class="headerlink" title="本编"></a>本编</h1><p>首先调用所需的 Python 库：</p><pre><code class="python">import numpy as npimport scipy.signal as signalimport matplotlib.pyplot as pltimport wfdbfrom matplotlib.font_manager import FontPropertiesmyfont = FontProperties(fname=r&#39;C:/Windows/Fonts/msyh.ttf&#39;)# set default size of plotsplt.rcParams[&#39;figure.figsize&#39;] = (15, 4) </code></pre><h2 id="理想窗函数滤波器"><a href="#理想窗函数滤波器" class="headerlink" title="理想窗函数滤波器"></a>理想窗函数滤波器</h2><p>理想窗函数的频响如图，频谱在<strong>通带和阻带之间直接截断</strong>，没有过渡带，如果是一个非因果的双边滤波器，则他的时域响应是一个离散的升余弦函数：<br>$$h_{ideal}[n] = \frac{\sin(2 \pi f_c)}{\pi n} = 2f_c sinc(2f_c n)$$</p><p>而一个因果的单边理想窗函数 LPF 的频响示意图如下：<br><img src="/signalsystem-project/2016-03-19_56ed1bb0681e3.png" class="[class names]" title="[20] [12] [ideal window filter [alt text]]"></p><p>接下来用理论的时域响应函数通过FFT得到因果和非因果窗函数各自的频响：</p><pre><code class="python">#one side signal (karma)def sinc_n(M, fc):    return 2 * fc * np.sinc(2 * fc * np.arange(0, M, 1.0))#two side signal (non-karma)def sincdouble_n(M, fc):    return 2 * fc * np.sinc(2 * fc * np.arange(-M, M, 1.0))</code></pre><pre><code class="python">def sinc_freqz(b, title, semilogx = False, showpart = False):    &#39;&#39;&#39;     calculate Z transform.    Cut-out in time domain signal cause side lobes in Frequency Responce&#39;&#39;&#39;    w, h = signal.freqz(b)    h_dB = 20 * np.log10(abs(h))    f = w / (np.pi)       #regularize frequncy to be between 0 and 1    plt.rcParams[&#39;figure.figsize&#39;] = (15, 4)     if showpart == False: plt.subplot(122)    # select plot mode: log space or linear space    if semilogx == True:        plt.semilogx(f, h_dB)    else:        plt.plot(f, h_dB)        plt.plot([0, 1], [-21, -21], &#39;k--&#39;, LineWidth = 1.0)        plt.text(0.26, -21, &#39;MSB of sinc double = -21 dB&#39;, fontdict={&#39;size&#39;: 16})    plt.xlabel(&#39;$\omega$&#39;)    plt.ylabel(&#39;$H (dB)$&#39;)    # if compare between different sample number    if showpart == False:        plt.subplot(121)        plt.stem(b)        plt.plot(b, &#39;--&#39;)        plt.xlabel(&#39;$n$&#39;)        plt.ylabel(&#39;$h(n)$&#39;)        plt.title(&#39;FIR &#39; + title)        plt.show()    return f, h_dB</code></pre><pre><code class="python"># M is width of window in time domainM = 30fc = 0.125# one/two side sinc signal in time domainb = sinc_n(M, fc)b1 = sincdouble_n(M, fc)f, h_dB = sinc_freqz(b, &#39;rectangle window&#39;)f1, h1_dB = sinc_freqz(b1, &#39;rectangle window (two-side)&#39;)</code></pre><img src="/signalsystem-project/20171226231409.png" class="[class names]" title="[26] [16] [ideal win fr [alt text]]"><p><strong>结论：</strong></p><ol><li>将两种理想窗函数相比较后，两种窗函数都出现了吉布斯现象（由于 FIR 本身特性不可避免）两种理想右上角的子图中，低通旁瓣更加明显；单边窗出现了负谱现象，并且高频段的抑制效果比双边窗的差很多。</li><li>比较单边和双边窗函数的 MSB （最小阻带衰减），单边窗的 MSB 远小于双边窗的，这意味着单边窗的低通滤波性能远不如双边窗。而双边窗的 MSB 增益也只有 -21dB ，这也是不足以实际产生功用的。</li></ol><p>进一步探究窗的宽窄对 MSB 参数的影响：</p><pre><code class="python">Ms = [8, 16, 32, 64, 90, 160]cache = dict()for i, M in enumerate(Ms):    cache[&#39;b&#39; + str(i)] = sincdouble_n(M, fc)    _, _ = sinc_freqz(cache[&#39;b&#39; + str(i)], &#39;rectangle window, M = &#39;+str(M), showpart=True)plt.xlim([0.2, 1])plt.show()</code></pre><img src="/signalsystem-project/different_M.png" class="[class names]" title="[26] [8] [ideal win fr [alt text]]"><p><strong>结论：</strong><br>改变窗的宽窄对理想双边窗函数的 MSB 参数没有影响，MSB 之和零点的位置和多少有关。</p><h2 id="其他常用的窗函数"><a href="#其他常用的窗函数" class="headerlink" title="其他常用的窗函数"></a>其他常用的窗函数</h2><p>矩形窗，也就是理想窗由于过于突出的缺点——旁瓣较高即 MSB 小导致变换中带入高频干扰和泄露，在实践中往往被其他窗函数代替，以实现更快的衰减，更小的泄露等关键性能。</p><p>常见窗函数：</p><ul><li>Hanning 汉宁窗：<br>$$\omega[k] = 0.5 - 0.5\cos \frac{2\pi k}{M}\quad(0 \leq k \leq M)$$<br>优点：与矩形窗相比，泄漏、波动都减小,并且提高选择性</li><li>Hamming 海明窗：<br>$$\omega[k] = 0.54 - 0.46\cos \frac{2\pi k}{M}\quad(0 \leq k \leq M)$$<br>特点：仅与 Hanning 的权重不同，都是改进的升余弦窗</li><li>Gaussian 窗：课堂上经常提到，不展开<br>-Blackman 布莱克曼窗：<br>$$\omega[k] = 0.42 - 0.5\cos \frac{2\pi k}{M}+0.08\cos \frac{4\pi k}{M}\quad(0 \leq k \leq M)$$<br>特点：二阶升余弦窗，主瓣宽，旁瓣比较低，但等效噪声带宽比汉宁窗要大一点，波动却小一点。频率识别精度最低，但幅值识别精度最高，有更好的选择性。</li><li>Kaiser 凯泽窗：<br>$$\omega[k] = \frac{I_0[\beta \sqrt{1 - (1 - \frac{2k}{M - 1})^2}]}{I_0 [\beta]}\quad(0 \leq k \leq M - 1)$$<br>特性：Kaiser 窗的性能和旁瓣宽度与参数$\beta$有关</li></ul><p>利用 scipy 科学计算包中封装好的 <code>signal.firwin</code> 类方法来可视化这些窗函数：</p><pre><code class="python">def get_window(wintype, Nx, cutoff = 0.5):       &#39;&#39;&#39; Nx is equivalent to M &#39;&#39;&#39;    wins = dict()    for w in wintype:        win = signal.firwin(2 * Nx, cutoff, window=w)        wins[w] = win        plt.rcParams[&#39;figure.figsize&#39;] = (15, 10)         plt.subplot(211)        plt.plot(win, label = w)        plt.xlabel(&#39;$n$&#39;)        plt.ylabel(&#39;$w(n)$&#39;)        plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)        plt.subplot(212)        win_f, h = signal.freqz(win)        plt.plot((win_f / (2 * np.pi))[200:], (20 * np.log10(abs(h)))[200:], label = w)        plt.xlabel(&#39;$\omega$&#39;)        plt.ylabel(&#39;$H (dB)$&#39;)        plt.title(&#39;amplitude response&#39;)        plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)    return wins</code></pre><pre><code class="python">firwins = get_window([&quot;blackman&quot;,             &quot;hamming&quot;,             &quot;hann&quot;,             (&#39;kaiser&#39;, 4.5513)], 61)        #beta = 4.5513plt.show()</code></pre><img src="/signalsystem-project/4wins.png" class="[class names]" title="[26] [16] [ideal win fr [alt text]]"><p><strong>结论：</strong></p><ol><li>这些常见窗函数的 MSB 特性都优于理想矩形窗函数（无论是双边还是单边），</li><li>由于是二阶滤波器，给定窗口范围时的 Blackman 窗的旁瓣增益最大；Kaiser 窗的 MSB、旁瓣宽度等形状特点根据 $\beta$ 的改变而不同。</li></ol><p>将 Blackman 窗的频响与双边矩形窗对比：</p><pre><code class="python">b3 = signal.firwin(len(b1), 0.22)w3, h3 = signal.freqz(b3)h3_dB = 20 * np.log10(abs(h3))f3 = w3 / (np.pi)plt.rcParams[&#39;figure.figsize&#39;] = (15, 4) plt.plot(f1, h1_dB, label = &#39;rect&#39;)plt.plot(f3, h3_dB, label = &#39;firwin&#39;)plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)plt.show()</code></pre><img src="/signalsystem-project/compare.png" class="[class names]" title="[26] [16] [ideal win fr [alt text]]"><p>可以看出前者的性能明显优于后者。</p><h2 id="signal-filtfilt-和-signal-lfilter"><a href="#signal-filtfilt-和-signal-lfilter" class="headerlink" title="signal.filtfilt 和 signal.lfilter"></a>signal.filtfilt 和 signal.lfilter</h2><p>当我们对上述设计并实现的 FIR 数字滤波器进行比对和选择之后，遴选出的一些滤波器将会用于实际应用。这就需要用到 scipy 库中给出的信号与滤波器相作用的方法，其中有两种不同的滤波函数：<code>signal.filtfilt</code> 和 <code>signal.lfilter</code>。在查阅官方 doc 之后，由于两个 filter 函数的 API 都很类似，没有很好地展示两个实际上的区别，</p><p>下面用一个简单的信号来 demo 一下两者的区别，输入是一个低频率和一个高频率叠加形成的信号：</p><pre><code class="python">def filtfilt_demo(b,a,x, lim = (0, 400)):    (l, h) = lim    y = signal.filtfilt(b, a, x)    plt.plot(y[l: h])    plt.show()    return ydef lfilter_demo(b,a,x, lim = (0, 400)):    (l, h) = lim    y = signal.lfilter(b, a, x)    plt.plot(y[l: h])    plt.show()    return y</code></pre><pre><code class="python">t = np.linspace(0, 1.0, 2001)&#39;&#39;&#39;contruct signal with a low freq component and a high freq component&#39;&#39;&#39;x_high = np.sin(2 * np.pi * 5 * t)x_low = np.sin(2 * np.pi * 250 * t)x = x_high + x_lowplt.rcParams[&#39;figure.figsize&#39;] = (10,3)plt.plot(x[0:250])plt.show()#build Butterworth filternom, denom = signal.butter(8, 0.125, btype=&#39;low&#39;)    # LPF_ = filtfilt_demo(nom, denom, x)_ =lfilter_demo(nom,denom, x)</code></pre><img src="/signalsystem-project/filterlfilter.png" class="[class names]" title="[20] [26] [ideal win fr [alt text]]"><p><strong>结论：</strong><br>对于低通滤波器，用 <code>signal.filtfilt</code> 施加在输入信号上时，输出信号的前几个时刻就已经很好的显现出低频信号的效果，这是因为函数将滤波器一前一后作用在了输入上两次；<br>而 <code>signal.lfilter</code> 只对输入信号作用一次，因此需要迟疑一段时间才能收敛到理论输出信号上。</p><h2 id="对-ECG-时序信号的处理"><a href="#对-ECG-时序信号的处理" class="headerlink" title="对 ECG 时序信号的处理"></a>对 ECG 时序信号的处理</h2><p>ECG，即 Electrocardiogram 心电图，是记录人的心脏跳动等特征的一种常见医疗影像数据，由心电仪探测得到的时序 ECG 数据不可避免的会夹杂环境噪声，下面利用开源数据集 <a href="https://github.com/MIT-LCP/wfdb-python" target="_blank" rel="noopener">wfdb</a> 进行心电图时序信号的处理</p><p>首先从实现下载并部署到 python 库中的 wfdb dataset 提取出一列 ECG 采样数据 <code>sampledata/100</code>，采样点设置为 15000 个:</p><pre><code class="python">signals, fields=wfdb.srdsamp(&#39;sampledata/100&#39;, sampfrom=100, sampto=15000)</code></pre><pre><code class="python"># Convert one channel to processable data# Argument &quot;fs_target&quot; stands for resampling freqdata, _ = wfdb.processing.resample_sig(x=signals[:,0], fs=fields[&#39;fs&#39;], fs_target=1280)</code></pre><pre><code class="python">plt.plot(data[:5000])plt.show()</code></pre><p>打印出其中一段提取出的数据：<br><img src="/signalsystem-project/data.png" class="[class names]" title="[26] [10] [ideal win fr [alt text]]"><br>可以看到这段记录的心电图曲线叠加了很多细微的高频噪声，但尚未淹没基本的上升下降的规律——每个周期内都有一个很短的高峰值紧跟着两到三个小幅振动。我们只想要保留这些相对噪声而言比较稳定的低频信号，而将噪声过滤掉。</p><p>通过傅里叶变换得到 wfdb data 的频谱：</p><pre><code class="python">&#39;&#39;&#39;select a test freqency to observe the spectrum of the signal&#39;&#39;&#39;f_test = 0.3#add a f_test frequency sin wave to the signaldata_prime = data +  0.1 * np.sin(f_test * np.arange(0, len(data), 1.0))spectrum = np.fft.fft(data_prime)spectrum_test = np.fft.fft(data)plt.plot(abs(spectrum), label = &#39;signal&#39;)plt.plot(abs(spectrum_test), label = &#39;test&#39;)plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)plt.show()</code></pre><img src="/signalsystem-project/dataspectrum.png" class="[class names]" title="[20] [8] [ideal win fr [alt text]]"><p>下一步是用 FIR 低通滤波器过滤提取出的 ECG 数据。滤波器使用 Blackman 窗。</p><pre><code class="python">firwin = get_window([&#39;blackman&#39;, (&#39;kaiser&#39;, 6)], 500, 0.2)</code></pre><pre><code class="python">d_firwin = np.convolve(firwin[&#39;blackman&#39;], data)d_b3 = np.convolve(b3, data)lim = 5000plt.rcParams[&#39;figure.figsize&#39;] = (15, 5) plt.subplot(311)plt.plot(data[: lim])plt.ylim([-1.0, 1.0])plt.text(lim, 0, &#39;original&#39;)plt.subplot(312)plt.plot(d_firwin[: lim])plt.ylim([-1.0, 1.0])plt.text(lim, 0, &#39;firwin&#39;)plt.subplot(313)plt.plot(d_b3[: lim])plt.ylim([-1.0, 1.0])plt.text(lim, 0, &#39;b3&#39;)plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)plt.ylim([-1.0, 1.0])plt.show()</code></pre><img src="/signalsystem-project/firwfdb.png" class="[class names]" title="[20] [8] [ideal win fr [alt text]]"><p>由于 窗函数的阶数较低，效果不是很理想。下面使用 <code>signal.butter</code> 函数提供的 Butterworth 型滤波器，现在将多阶滤波器的滤波效果进行对比：</p><pre><code class="python">nom1, denom1 = signal.butter(8, 0.038, btype=&#39;low&#39;)d_filtered = filtfilt_demo(nom1, denom1, data, (0, 2000))</code></pre><p>滤波后的输出信号如下图<br><img src="/signalsystem-project/butter.png" class="[class names]" title="[20] [8] [ideal win fr [alt text]]"></p><p>分析 Butterwoth 的零极点情况：</p><pre><code class="python">(r, p, k) = signal.residuez(nom1, denom1)plt.plot(r.real, r.imag, &#39;o&#39;)plt.plot(p.real, p.imag, &#39;x&#39;)circ = plt.Circle((0, 0), radius=1, edgecolor = &#39;b&#39;, facecolor = &#39;None&#39;)plt.gca().add_patch(circ)plt.xlim([-2, 2])plt.ylim([-2, 2])plt.gca().set_aspect(&#39;equal&#39;)plt.show()</code></pre><img src="/signalsystem-project/residuez.png" class="[class names]" title="[8] [8] [ideal win fr [alt text]]"><p>零点和极点的个数各有 8 个，此时可以达到良好的滤波效果。</p><p>将输入信号与输出信号进行波形的对比（为了可视化效果，在同一张图上显示时将两个波形错开）：</p><pre><code class="python">plt.plot(data[:2000], label = &#39;signal&#39;)plt.plot(d_filtered[:2000] - 0.1, label = &#39;Butter&#39;)plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)plt.show()</code></pre><img src="/signalsystem-project/io.png" class="[class names]" title="[20] [8] [ideal win fr [alt text]]"><p>可以看出通过 Butterworth 滤波器的输出波形基本还原了输入心电图数据的走势，很好地分离了高频低频分量，同时也保留了脉冲峰值高度（损失了大约 0.2 的增益）</p><p>如果将刚才的阶数为 8 的滤波器改成高通滤波器，输出应该会得到只含有高频分量的信号。将参数 <code>btype</code> 设为 <code>&quot;high&quot;</code>：</p><pre><code class="python">nom2, denom2 = signal.butter(8, 0.038, btype=&#39;high&#39;)d2_filtered = filtfilt_demo(nom2, denom2, data, (0, 2000))</code></pre><img src="/signalsystem-project/HPF.png" class="[class names]" title="[20] [8] [ideal win fr [alt text]]"><pre><code class="python">plt.plot(data[:2000], label = &#39;signal&#39;)plt.plot(d_filtered[:2000] - 0.1, label = &#39;low&#39;)plt.plot(d2_filtered[:2000], label = &#39;high&#39;)plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)plt.show()</code></pre><img src="/signalsystem-project/turbo.png" class="[class names]" title="[20] [8] [ideal win fr [alt text]]"><p>观察波形，发现和 HPF 的输出和原始波形中的大部分噪声的震动部分相同，如果想尝试进一步优化 LPF 输出波形，一个自然的想法是将这两部分做减法，观察将得到什么结果：</p><pre><code class="python">k = int(len(data) / 256)r = len(data) % 256for i in range(1, k):    d2_filtered[i * 256 + 1: (i + 1) * 256] = data[0: 255] - np.mean(data[0: 255])d2_filtered[len(data) - r: len(data) - 1] = data[255 - r + 1: 255] - np.mean(data[0: 255])mini = min(d2_filtered[0: 750])maxi = max(d2_filtered[0: 750])for i in range(len(data)):    if d2_filtered[i] &gt; maxi: d2_filtered[i] = maxi    elif d2_filtered[i] &lt; mini: d2_filtered[i] = mini</code></pre><pre><code class="python">plt.plot(d2_filtered[:2000], label = &#39;high&#39;)plt.plot(data[: 2000] - d2_filtered[:2000], label = &#39;d_filtered_new&#39;)plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)plt.show()</code></pre><img src="/signalsystem-project/minus.png" class="[class names]" title="[20] [8] [ideal win fr [alt text]]"><p>结果显示这个尝试并不成功。黄色的曲线显示了做减法之后的输出波形，尽管原有的脉冲峰值基本没有损失，但曲线并没有变得光滑。</p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p><strong>源代码 / 英文报告</strong>：<a href="https://github.com/Akimoto-Cris/SignalSystem_project/blob/master/15343087_%E5%BE%90%E5%87%AF%E6%98%95_%E4%BF%A1%E5%8F%B7%E7%B3%BB%E7%BB%9F%E5%A4%A7%E4%BD%9C%E4%B8%9A_FIR.ipynb" target="_blank" rel="noopener">https://github.com/Akimoto-Cris/SignalSystem_project</a></p><p><strong>参考：</strong><br><a href="http://blog.csdn.net/shenziheng1/article/details/53366067" target="_blank" rel="noopener">http://blog.csdn.net/shenziheng1/article/details/53366067</a></p><p>wfdb dataset: <a href="https://github.com/MIT-LCP/wfdb-python" target="_blank" rel="noopener">https://github.com/MIT-LCP/wfdb-python</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Markdown Basic Grammar</title>
      <link href="/2017/12/26/markdown-basic-grammar/"/>
      <url>/2017/12/26/markdown-basic-grammar/</url>
      
        <content type="html"><![CDATA[<p>Markdown is a “HTML”-like tag language, What you see is what you get, just follow some basic rules and you get beautiful page. This is a cheatsheet and simple demonstration of Markdown as my first blog on HEXO.</p><h1 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h1><pre><code># H1or:H1-prime======## H2or:H2-prime------### H3###### H6</code></pre><p>效果：</p><h1 id="H1"><a href="#H1" class="headerlink" title="H1"></a>H1</h1><p>or:</p><h1 id="H1-prime"><a href="#H1-prime" class="headerlink" title="H1-prime"></a>H1-prime</h1><h2 id="H2"><a href="#H2" class="headerlink" title="H2"></a>H2</h2><p>or:</p><h2 id="H2-prime"><a href="#H2-prime" class="headerlink" title="H2-prime"></a>H2-prime</h2><h3 id="H3"><a href="#H3" class="headerlink" title="H3"></a>H3</h3><h6 id="H6"><a href="#H6" class="headerlink" title="H6"></a>H6</h6><h2 id="Compared-to-html"><a href="#Compared-to-html" class="headerlink" title="Compared to html:"></a>Compared to html:</h2><pre><code>&lt;h1/&gt; H1&lt;h2/&gt; H2...&lt;h5/&gt; H5</code></pre><p></p><h1> H1<p></p><p></p><h2> H2<br>…<p></p><p></p><h5> H5<p></p><h1 id="Emphasis"><a href="#Emphasis" class="headerlink" title="Emphasis"></a>Emphasis</h1><p>斜体、加粗、斜体加粗、划去效果：</p><pre><code>*italics* or _italics_**bold** or __bold__**combine or _combine_**~~Scratch.~~</code></pre><p>效果：<br><em>italics</em> or <em>italics</em><br><strong>bold</strong> or <strong>bold</strong><br><strong>combine or <em>combine</em></strong><br><del>Scratch.</del></p><h1 id="大纲式列表"><a href="#大纲式列表" class="headerlink" title="大纲式列表"></a>大纲式列表</h1><pre><code>1. 第一点（识别机制：“任意数字 + . + 半角空格”）2. 第二点10. 第三点..* 打点子列4. 第四点 第一段...第二段* Unordered list can use asterisks- Or minuses+ Or pluses</code></pre><h1 id="插入URL-和-图片"><a href="#插入URL-和-图片" class="headerlink" title="插入URL 和 图片"></a>插入URL 和 图片</h1><p>URL:    <a href="your url">some text</a> 如：<code>[B站](https://www.bilibili.com)</code><br><a href="https://www.bilibili.com" target="_blank" rel="noopener">B站</a></p><p>Image:    <img src="image&#39;s url" alt="some text"> 如：<code>![alt text](https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png &quot;Logo Title Text 1&quot;)</code><br>鼠标在图片上悬停看title:<br><img src="https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png" alt="alt text" title="Logo Title Text 1"></p><h2 id="Compared-to-html-1"><a href="#Compared-to-html-1" class="headerlink" title="Compared to html"></a>Compared to html</h2><pre><code>&lt;a ref = &quot;https://www.bilibili.com&quot;&gt;B站&lt;/a&gt;&lt;img src=&quot;https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png&quot;&gt;Logo Title Text 1&lt;/img&gt;</code></pre><p><a ref="https://www.bilibili.com">B站</a><br><img src="https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png">Logo Title Text 1</p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>行内代码用单引号 <code></code>code<code></code> :<br>Inline <code>code</code> is here.<br>整块代码用三个引号, 注释语言显示语法高亮：</p><pre><code>```javascriptvar s = &quot;JavaScript syntax highlighting&quot;;alert(s);</code></pre><pre><code class="python">s = &quot;Python syntax highlighting&quot;print s</code></pre><pre><code>No language indicated, so no syntax highlighting. But let&#39;s throw in a &lt;b&gt;tag&lt;/b&gt;.</code></pre><pre><code>```javascriptvar s = &quot;JavaScript syntax highlighting&quot;;alert(s);</code></pre><pre><code class="python">s = &quot;Python syntax highlighting&quot;print s</code></pre><pre><code>No language indicated, so no syntax highlighting. But let&#39;s throw in a &lt;b&gt;tag&lt;/b&gt;.</code></pre><h1 id="水平分隔符"><a href="#水平分隔符" class="headerlink" title="水平分隔符"></a>水平分隔符</h1><p>三个以上的 ‘-‘, ‘*’ 或者 ‘_’</p><pre><code>A---B***C___D*****</code></pre><p>效果：</p><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p>B</p><hr><p>C</p><hr><p>D</p><hr><h1 id="LaTex-公式"><a href="#LaTex-公式" class="headerlink" title="LaTex 公式"></a>LaTex 公式</h1><p>在写这篇blog之前，本来以为只要在公式两头加 $ 或者 $$ 符号就搞定了，没想到在 Hexo 中渲染 LaTex 公式并不容易，</p><p>Hexo 中 LaTex 公式异常的主要原因是 Markdowm 和 Latex 的语法冲突（参考<a href="https://fsh0524.github.io/2016/03/03/LaTeX-in-Hexo/" target="_blank" rel="noopener">这篇博客</a>），这个问题得不到很好的解决，不能像 Jupyter Notebook 里一样直接在 Markdown 中间插入 Latex 都没问题。</p><p>解决方法：</p><ol><li>有一些 hexo 主题本身支持 Mathjax 插件，比如我使用的 <a href="https://material.viosey.com/docs/#/compose?id=front-matter" target="_blank" rel="noopener">material 主题</a>，只需要在博客中指定开启这个插件就解决了；<br>… 默认的 landscape 主题的 Mathjax 原本有 BUG 但可能现在已经修复了：<br>… landscape 的官方说明：<div class="video-container"><iframe src="//www.youtube.com/embed/YZ7txjZHBO4" frameborder="0" allowfullscreen></iframe></div></li><li>如果主题不支持这个插件的话，要安裝 hexo-math ：<code>npm install hexo-math --save</code>。如果仍然渲染失败的话，手动在 html 文件里面加入 mathjax 的 JavaScript</li></ol><p>真心希望 hexo 更新的时候可以内置支持…<br>渲染测试：（失败）</p><pre><code>$$\frac{\partial ^2 \varphi}{\partial x^2}$$$$\sigma \Sigma$$行内公式：$\varphi=\frac{Q}{4\pi \epsilon\_0 r}$</code></pre><p>效果：<br>$$\frac{\partial ^2 \varphi}{\partial x^2}$$<br>$$\sigma \Sigma$$<br>行内公式：$\varphi=\frac{Q}{4\pi \epsilon_0 r}$</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet" target="_blank" rel="noopener">https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet</a></p></h5></h2></h1>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>内存管理 —— 超量写内存</title>
      <link href="/2017/12/24/memoryexcess/"/>
      <url>/2017/12/24/memoryexcess/</url>
      
        <content type="html"><![CDATA[<p>这几天觉得在打 Python 的时候觉得自己欠缺了一点 Data structure 的头脑， 于是去学校图书馆借了一本《算法之美》（是的，书名看起来很民科，但其实内容的深度还是有的）</p><p>接下来的时间我打算一点点有选择性地总结一些对我等只学了一点 C 的皮毛的非科班菜鸡有启发的章节</p><p><strong>超量写内存是什么问题？</strong></p><p>超量写内存，顾名思义，是操作的内存超过了先前开辟的内存，有一点 Overflow 的味道在里面。</p><p>即使在一个指针被正确的初始化的前提下，指针运算中的错误，或者错误的内存地址操作，仍然会引起内存管理上的错误。</p><h2 id="数组指针的越界访问"><a href="#数组指针的越界访问" class="headerlink" title="数组指针的越界访问"></a>数组指针的越界访问</h2><p>当定义一些数组的下标的时候很容易犯这种错，尽管我们早就知道一个数组的下标都是从0开始的。一种常识的选择性遗忘。</p><p>容量为<code>array_size</code>的数组 a 是不存在元素<code>a[array_size]</code>的，如果用了这个不存在的元素，结果就是可能改变程序里其他数据的值（如果内存中下一个地址也在程序中有另一个定义）</p><h2 id="内存分配不足"><a href="#内存分配不足" class="headerlink" title="内存分配不足"></a>内存分配不足</h2><p>例1：</p><pre><code class="c++">#define array_size 10int *a = new int[array_size];... ...int *b = new int[array_size];... ...memcpy(b, a, array_size);</code></pre><p>看起来没毛病，错在<code>memcpy</code>的第三个参数应该是数组的物理大小，并不是元素的多少，所以还要乘以 int 类型的字节数：<code>memcpy(b, a, array_size * sizeof(int))</code></p><p>例2：</p><pre><code class="c++">char *new_string(char *s){    int len = strlen(s);    char *new_string = new char[len];    strcpy(new_s, s);    return new_s;}</code></pre><p>字符串结尾有一个隐性的结束符’\0’，因此应该给新字符串分配的内存字节数为<code>len + 1</code></p><h2 id="操作符的优先权"><a href="#操作符的优先权" class="headerlink" title="操作符的优先权"></a>操作符的优先权</h2><p>“操作符的优先权也有可能致使程序员访问了不该访问的地址，不慎的使用*和++或—都有可能导致超量写内存”</p><p>这一点暂时没有想到如何避免</p><hr><p>另一个可能的错误是构造一个指向运行时栈中某值的指针，并将这个指针返回给函数调用者，例如：</p><pre><code class="c++">int *p(){    int i = 0;    return &amp;i;}</code></pre><p>这个函数定义的指针在函数返回值后就会出栈而变成毫无意义的随机地址、随机值。</p><h2 id="链接："><a href="#链接：" class="headerlink" title="链接："></a>链接：</h2><p><a href="https://book.douban.com/review/1325850/" target="_blank" rel="noopener">豆瓣《算法之美》点评 https://book.douban.com/review/1325850/</a></p><p><a href="www.cnblogs.com/mx113/articles/1603990.html">www.cnblogs.com/mx113/articles/1603990.html</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>哈希表的 Python 实现</title>
      <link href="/2017/12/24/wheel_hash/"/>
      <url>/2017/12/24/wheel_hash/</url>
      
        <content type="html"><![CDATA[<p>将哈希表定义成具有插值、查找值、删除值、复写字符串方法的 Python 类：</p><pre><code class="python">class hashSet(object):    def __init__(self, numBuckets):         &#39;&#39;&#39;        numBuckets: int. The number of buckets this hash set will have.         Raises ValueError if this value is not an integer, or if it is not greater than zero.        Sets up an empty hash set with numBuckets number of buckets.        &#39;&#39;&#39;        if type(numBuckets) != int or numBuckets &lt;= 0:            raise ValueError        self.NUM_BUCKETS = numBuckets        self.set = []        for i in range(self.NUM_BUCKETS):            self.set.append([])    def hashValue(self, e):        &#39;&#39;&#39;        e: an integer        returns: a hash value for e, which is simply e module of the number of         buckets in this hash set. Raises ValueError if e is not an integer.        &#39;&#39;&#39;        if type(e) != int:            raise ValueError        return e % self.NUM_BUCKETS    def member(self, e):        &#39;&#39;&#39;        e: an integer        Returns True if e is in self, and False otherwise. Raises ValueError if e is not an integer.        &#39;&#39;&#39;        if type(e) != int:            raise ValueError        return e in self.set[self.hashValue(e)]    def insert(self, e):        &#39;&#39;&#39;        e: an integer        Inserts e into the appropriate hash bucket. Raises ValueError if e is not an integer.        &#39;&#39;&#39;         if type(e) != int:            raise ValueError        self.set[self.hashValue(e)].append(e)    def remove(self, e):        &#39;&#39;&#39;        e: is an integer         Removes e from self        Raises ValueError if e is not in self or if e is not an integer.        &#39;&#39;&#39;         if type(e) != int or not self.member(e):             raise ValueError        find = self.set[self.hashValue(e)]        del find[find.index(e)]    def getNumBuckets(self):        &#39;&#39;&#39;        Returns number of buckets.        &#39;&#39;&#39;        return self.NUM_BUCKETS    def __str__(self):        &#39;&#39;&#39;        Returns string representation of data inside hash set.        &#39;&#39;&#39;        result = &quot;&quot;        bucketNr = 0        for bucket in self.set:            result += str(bucketNr) + &quot;: &quot; + &quot;,&quot;.join(str(e) for e in bucket) + &quot;\n&quot;            bucketNr += 1        return result</code></pre>]]></content>
      
      
      
    </entry>
    
  
  
</search>
